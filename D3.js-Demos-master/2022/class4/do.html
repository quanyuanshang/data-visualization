<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="d3.min.js"></script>
    <title>pie</title>
</head>

<body>
    <svg width="1600" height="800" id="mainsvg" class="svgs"></svg>
    <script>
        const svg = d3.select('svg');
        const width = svg.attr('width');
        const height = svg.attr('height');
        const margin = { top: 100, right: 100, bottom: 100, left: 150 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        const mainGroup = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`)

        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();
        const xValue = d => d.year;
        const yValue = d => d.globalsale;
        const colorScale = d3.scaleOrdinal();
        let yearsData;
        let pgyData;
        const crossLineX = svg.append('line').attr('class', 'crossLine')
        const crossLineY = svg.append('line').attr('class', 'crossLine');

        const arcGenerator = d3.arc()
            .innerRadius(0).outerRadius(105);
        const outerArcGenerator = d3.arc()
            .innerRadius(40).outerRadius(185);
        const pie = d3.pie().value(yValue);


        const midAngle = function (d) {
            return d.startAngle + (d.endAngle - d.startAngle) / 2;
        };

        const isGoodAngle = function (d) {
            return (d.endAngle - d.startAngle) >= 0.3;
        };

        const arcTween = function (d) {
            var init_startAngle = 0;
            var init_endAngle = 0;
            var interpolate_start = d3.interpolate(init_startAngle, d.startAngle);
            var interpolate_end = d3.interpolate(init_endAngle, d.endAngle);
            return function (t) {
                d.startAngle = interpolate_start(t);//// 起始角度补间器
                d.endAngle = interpolate_end(t);
                return arcGenerator(d)//用当前角度生成SVG路径
            }
        }
        const tweenDash = function () {
            let l = this.getTotalLength(),
                i = d3.interpolateString("0," + l, l + "," + l);
            return function (t) { return i(t); };
        }
        const renderPie = function (datum, x, y) {
            d3.selectAll('#arcGroup').remove();
            const data = pgyData.filter(d => d.year === datum.year && yValue(d) !== 0);

            let arcGroup = mainGroup.append('g').attr('id', 'arcGroup')
                .attr('transform', `translate(${x}, ${y})`);
            console.log(data.map(d => d.platform)); // 应该输出多个不同平台名
            console.log(colorScale.domain());       // 应该输出所有平台名
            console.log(colorScale.range());
            //pie(data) 返回的是一个数组，每个元素都包含：
            // startAngle：扇形起始角度
            // endAngle：扇形结束角度
            // value：原始数据的值（如销量）
            // data：原始数据对象（如 {platform: "PS4", globalsale: 123}）
            arcGroup.selectAll('path').data(pie(data)).join('path')
                .attr('fill', d => colorScale(d.data.platform))
                .on('click', () => { d3.selectAll('#arcGroup').remove(); })
                .transition().duration(1000).attrTween('d', arcTween);
            //为饼图的每个扇形绘制标签指示线（polyline），并添加动画效果。
            arcGroup.selectAll('polyline').data(pie(data)).join('polyline')

                // 计算当前扇形的中心点（用于指示线起点）。

                // outerArcGenerator.centroid(d)
                // 计算当前扇形在外圆弧上的中间点（用于指示线的拐点）。

                // pos
                // 先取外圆弧上的中间点，然后根据扇形的角度决定标签线的终点在左侧还是右侧：

                // midAngle(d) < Math.PI：如果扇形在饼图右半边，标签线终点向右偏移 25 像素；
                // 否则向左偏移 25 像素。
                // return [arcGenerator.centroid(d), outerArcGenerator.centroid(d), pos]
                // 返回一个包含三个点的数组，分别是：

                // 扇形中心点（起点）
                // 外圆弧中点（拐点）
                // 标签线终点（标签文本位置）
                .attr('opacity', d => isGoodAngle(d) ? 1 : 0)
                .attr('stroke', 'black').attr('stroke-width', '2px').attr('fill', 'none')
                .attr('points', d => {
                    let pos = outerArcGenerator.centroid(d);
                    pos[0] = 130 * (midAngle(d) < Math.PI ? 1 : -1);;
                    return [arcGenerator.centroid(d), outerArcGenerator.centroid(d), pos];
                }).transition().duration(1000).attrTween("stroke-dasharray", tweenDash);

            arcGroup.selectAll('text').data(pie(data)).join('text')
                .text(d => d.data.platform) // 显示平台名
                .attr('font-size', '1em')
                .attr('transform', d => {
                    let pos = outerArcGenerator.centroid(d); // 计算外圆弧上的中点
                    pos[0] = 130 * (midAngle(d) < Math.PI ? 1 : -1); // 标签在左右两侧分布
                    return `translate(${pos[0]}, ${pos[1]})`; // 设置文本位置
                })
                .attr('text-anchor', d => midAngle(d) < Math.PI ? "start" : "end") // 左侧右对齐，右侧左对齐
                .transition().duration(1000)
                .attr('opacity', d => isGoodAngle(d) ? 1 : 0); // 角度太小的不显示标签


        }

        //then确保只有在数据加载完毕后，才开始处理和可视化数据。

        d3.csv('years.csv').then(data => {
            yearsData = data;
            d3.csv('pgyline.csv').then(data => {
                yearsData.sort((a, b) => {
                    return b.year - a.year;
                });
                yearsData.forEach(d => {
                    d.year = +d.year;
                    d.globalsale = +d.globalsale;
                });
                pgyData = data;
                pgyData.forEach(d => {
                    d.year = +d.year;
                    d.globalsale = +d.globalsale;
                });

                xScale.domain(d3.extent(yearsData, xValue)).range([0, innerWidth]).nice();
                yScale.domain(d3.extent(yearsData, yValue)).range([innerHeight, 0]).nice();
                const xAxis = d3.axisBottom(xScale).ticks(35).tickFormat(d3.format('d'));
                const yAxis = d3.axisLeft(yScale);
                const yAxisGroup = mainGroup.append('g').attr('id', 'yAxisGroup').call(yAxis);
                const xAxisGroup = mainGroup.append('g').attr('class', 'x-axis').call(xAxis).attr('transform', `translate(0, ${innerHeight})`);
                d3.selectAll('.tick text').attr('font-size', '1.2em');

                xAxisGroup.append('text').attr('class', 'axisTitle').text('Year')
                    .attr('x', innerWidth / 2).attr('y', 60);
                yAxisGroup.append('text').attr('class', 'axisTitle').text('Global Sale')
                    .attr('transform', 'rotate(-90)').attr('x', -innerHeight / 2).attr('y', -60);
                d3.selectAll('.axisTitle').attr('text-anchor', "middle").attr('fill', 'black').attr('font-size', '2em');

                const platforms = Array.from(new Set(pgyData.map(d => d.platform)));
                colorScale.domain(platforms);
                const sp = d3.scalePoint().domain(platforms).range([0, 1]);//创建一个 D3 的点状比例尺（scalePoint），用于将一组离散的类别（这里是 platforms，比如不同游戏平台）均匀地映射到 [0, 1] 这个连续区间。
                colorScale.range(platforms.map(d => d3.interpolateSpectral(sp(d))));//对每个平台名 d，用 sp(d) 得到它在 [0, 1] 区间上的位置（均匀分布）。用 d3.interpolateSpectral(sp(d)) 取色谱上的一个颜色（Spectral 是一种多色渐变色带）。
                //把所有平台的颜色组成数组，作为 colorScale 的输出色域（range）。

                const line = d3.line()
                    .x(d => { return xScale(xValue(d)) })
                    .y(d => { return yScale(yValue(d)) })
                    .curve(d3.curveCardinal.tension(0.99))//3次贝塞尔曲线，tension 控制曲线的“紧张度”，值越大曲线越接近折线
                mainGroup.append('path').attr('id', 'mainPath').datum(yearsData)
                    .attr('d', line).attr('fill', 'none').attr('stroke', 'black');//添加路径（线条、曲线、区域等）.append('path')
                mainGroup.selectAll('dataCircles').data(yearsData).join('circle')
                    .attr('class', 'dataCircles')
                    .attr('cx', d => xScale(xValue(d))).attr('cy', d => yScale(yValue(d))).attr('r', 10)
                    .attr('stroke-width', 2).attr('stroke', '#364747').attr('fill', '#364747').attr('opacity', 0.6)
                    .on('mouseover', function (event, d) {
                        d3.select(this).attr('stroke', '#38eff2');
                    }).on('mouseout', function (event, d) {
                        d3.select(this).attr('stroke', '#364747');
                    })
                    .on('click', function (event, d) {
                        let c = d3.select(this);
                        renderPie(d, c.attr('cx'), c.attr('cy'));
                        event.stopPropagation();
                    });


                svg.selectAll('.crossLine')
                    .attr('stroke', '#aaa')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '4 4');

                document.addEventListener('mousemove', function (event) {
                    const [x, y] = d3.pointer(event, svg.node());//获取鼠标在 SVG 内部的相对坐标即可
                    if (x <= margin.left || x >= width - margin.right || y <= margin.top || y >= height - margin.bottom) { return; }
                    crossLineX.attr('x1', x).attr('y1', y).attr('x2', margin.left).attr('y2', y);
                    crossLineY.attr('x1', x).attr('y1', y).attr('x2', x).attr('y2', height - margin.bottom);
                }, true);

                document.addEventListener('click', function (event) {
                    if (document.getElementById("arcGroup")) {
                        d3.select('#arcGroup').remove();
                    }
                }, { capture: false });

            })
        }) // <-- Add this closing brace to properly close the outer d3.csv().then

        // .append('g')  → 添加分组（group），可以把多个元素组织在一起，方便整体变换或样式设置
        // .append('circle') → 添加圆形
        // .append('rect') → 添加矩形
        // .append('text') → 添加文本
        // .append('line') → 添加直线
        // .append('polyline') → 添加折线
        // .append('polygon') → 添加多边形
    </script>

</body>

</html>